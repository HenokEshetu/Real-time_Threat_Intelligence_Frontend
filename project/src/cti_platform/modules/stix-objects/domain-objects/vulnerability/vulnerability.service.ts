import { Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';
import { Client } from '@opensearch-project/opensearch';
import { CreateVulnerabilityInput, UpdateVulnerabilityInput } from './vulnerability.input';
import { v4 as uuidv4 } from 'uuid';
import { SearchVulnerabilityInput } from './vulnerability.resolver';
@Injectable()
export class VulnerabilityService {
  private readonly index = 'vulnerabilities'; // OpenSearch index name

  private openSearchService: Client;
  constructor() {
    this.openSearchService = new Client({
      node: 'http://localhost:9200',
    });
  }

  async create(createVulnerabilityInput: CreateVulnerabilityInput): Promise<any> {
    if (createVulnerabilityInput.cve_id) {
      this.validateCveId(createVulnerabilityInput.cve_id);
    }
    if (createVulnerabilityInput.cvss_v3_score) {
      this.validateCvssScore(createVulnerabilityInput.cvss_v3_score);
    }

    const vulnerability = {
      id: `vulnerability--${uuidv4()}`,
      created: new Date().toISOString(),
      modified: new Date().toISOString(),
      ...createVulnerabilityInput,
    };

    try {
      await this.openSearchService.index({
        index: this.index,
        id: vulnerability.id,
        body: vulnerability,
        refresh: 'wait_for',
      });
      return vulnerability;
    } catch (error) {
      throw new InternalServerErrorException(`Failed to create vulnerability: ${error.message}`);
    }
  }

  async findOne(id: string): Promise<any> {
    try {
      const { body } = await this.openSearchService.get({
        index: this.index,
        id,
      });
      return body._source;
    } catch (error) {
      if (error.meta?.statusCode === 404) {
        throw new NotFoundException(`Vulnerability with ID ${id} not found.`);
      }
      throw new InternalServerErrorException(`Error fetching vulnerability: ${error.message}`);
    }
  }

  async findByCveId(cveId: string): Promise<any> {
    try {
      const { body } = await this.openSearchService.search({
        index: this.index,
        body: {
          query: {
            match: { cve_id: cveId },
          },
        },
      });

      if (body.hits.hits.length === 0) {
        throw new NotFoundException(`Vulnerability with CVE ID ${cveId} not found.`);
      }

      return body.hits.hits[0]._source;
    } catch (error) {
      throw new InternalServerErrorException(`Error searching vulnerability: ${error.message}`);
    }
  }

  async update(id: string, updateVulnerabilityInput: UpdateVulnerabilityInput): Promise<any> {
    if (updateVulnerabilityInput.cve_id) {
      this.validateCveId(updateVulnerabilityInput.cve_id);
    }
    if (updateVulnerabilityInput.cvss_v3_score) {
      this.validateCvssScore(updateVulnerabilityInput.cvss_v3_score);
    }

    try {
      const existingVulnerability = await this.findOne(id);
      const updatedVulnerability = {
        ...existingVulnerability,
        ...updateVulnerabilityInput,
        modified: new Date().toISOString(),
      };

      await this.openSearchService.index({
        index: this.index,
        id,
        body: updatedVulnerability,
        refresh: 'wait_for',
      });

      return updatedVulnerability;
    } catch (error) {
      throw new InternalServerErrorException(`Failed to update vulnerability: ${error.message}`);
    }
  }

  async remove(id: string): Promise<boolean> {
    try {
      const { body } = await this.openSearchService.delete({
        index: this.index,
        id,
        refresh: 'wait_for',
      });

      return body.result === 'deleted';
    } catch (error) {
      if (error.meta?.statusCode === 404) {
        throw new NotFoundException(`Vulnerability with ID ${id} not found.`);
      }
      throw new InternalServerErrorException(`Failed to delete vulnerability: ${error.message}`);
    }
  }

  async searchVulnerabilityWithFilters(
    filters:SearchVulnerabilityInput,
    page = 1,
    pageSize = 10,
    sortField = 'created',
    sortOrder: 'asc' | 'desc' = 'desc'
  ): Promise<any> {
    try {
      const from = (page - 1) * pageSize;
      const mustQueries = [];
      const shouldQueries = [];
      const filterQueries = [];
  
      for (const [key, value] of Object.entries(filters)) {
        if (!value) continue;
  
        // Handle array values (e.g., multiple tags or categories)
        if (Array.isArray(value)) {
          mustQueries.push({ terms: { [key]: value } });
        }
  
        // Handle exact matches for booleans & numbers
        else if (typeof value === 'boolean' || typeof value === 'number') {
          mustQueries.push({ term: { [key]: value } });
        }
  
        // Handle range queries (e.g., CVSS score, timestamps)
        else if (['cvss_v3_score', 'created', 'modified'].includes(key)) {
          if (typeof value === 'object' && ('gte' in value || 'lte' in value || 'gt' in value || 'lt' in value)) {
            filterQueries.push({ range: { [key]: value } });
          } else {
            filterQueries.push({ range: { [key]: { gte: value } } });
          }
        }
  
        // Handle advanced string searches
        else if (typeof value === 'string') {
          if (value.includes('*')) {
            // Wildcard search
            mustQueries.push({ wildcard: { [key]: value.toLowerCase() } });
          } else if (value.includes('~')) {
            // Fuzzy search (e.g., "log4j~" will match "log4j", "log4j2", etc.)
            shouldQueries.push({ fuzzy: { [key]: { value, fuzziness: 'AUTO' } } });
          } else if (value.startsWith('"') && value.endsWith('"')) {
            // Phrase match (exact phrase search)
            mustQueries.push({ match_phrase: { [key]: value.replace(/"/g, '') } });
          } else {
            // Default full-text search
            mustQueries.push({ match: { [key]: value } });
          }
        }
      }
  
      // Construct the OpenSearch query
      const query: any = { bool: {} };
      if (mustQueries.length > 0) query.bool.must = mustQueries;
      if (shouldQueries.length > 0) query.bool.should = shouldQueries;
      if (filterQueries.length > 0) query.bool.filter = filterQueries;
      if (Object.keys(query.bool).length === 0) query.bool.must = [{ match_all: {} }];
  
      // Execute search in OpenSearch
      const { body } = await this.openSearchService.search({
        index: this.index,
        from,
        size: pageSize,
        body: {
          query,
          sort: [{ [sortField]: { order: sortOrder } }],
        },
      });
  
      const total = typeof body.hits.total === 'number' ? body.hits.total : body.hits.total?.value ?? 0;
  
      return {
        total,
        page,
        pageSize,
        results: body.hits.hits.map((hit) => ({
          id: hit._id,
          ...hit._source,
        })),
      };
    } catch (error) {
      throw new InternalServerErrorException(`Error searching vulnerabilities: ${error.message}`);
    }
  }
  
  private validateCveId(cveId: string): void {
    const cvePattern = /^CVE-\d{4}-\d{4,}$/;
    if (!cvePattern.test(cveId)) {
      throw new Error('Invalid CVE ID format. Expected format: CVE-YYYY-NNNNN');
    }
  }

  private validateCvssScore(score: string): void {
    const numScore = parseFloat(score);
    if (isNaN(numScore) || numScore < 0 || numScore > 10) {
      throw new Error('CVSS score must be a number between 0.0 and 10.0');
    }
  }
}
